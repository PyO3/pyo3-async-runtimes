<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="Rust Bindings to the Python Asyncio Event Loop"><title>pyo3_async_runtimes - Rust</title><script>if(window.location.protocol!=="file:")document.head.insertAdjacentHTML("beforeend","SourceSerif4-Regular-46f98efaafac5295.ttf.woff2,FiraSans-Regular-018c141bf0843ffd.woff2,FiraSans-Medium-8f9a781e4970d388.woff2,SourceCodePro-Regular-562dcc5011b6de7d.ttf.woff2,SourceCodePro-Semibold-d899c5a5c4aeb14a.ttf.woff2".split(",").map(f=>`<link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/${f}">`).join(""))</script><link rel="stylesheet" href="../static.files/normalize-76eba96aa4d2e634.css"><link rel="stylesheet" href="../static.files/rustdoc-c5d6553a23f1e5a6.css"><meta name="rustdoc-vars" data-root-path="../" data-static-root-path="../static.files/" data-current-crate="pyo3_async_runtimes" data-themes="" data-resource-suffix="" data-rustdoc-version="1.81.0 (eeb90cda1 2024-09-04)" data-channel="1.81.0" data-search-js="search-d234aafac6c221dd.js" data-settings-js="settings-4313503d2e1961c2.js" ><script src="../static.files/storage-118b08c4c78b968e.js"></script><script defer src="../crates.js"></script><script defer src="../static.files/main-d2fab2bf619172d3.js"></script><noscript><link rel="stylesheet" href="../static.files/noscript-df360f571f6edeae.css"></noscript><link rel="alternate icon" type="image/png" href="../static.files/favicon-32x32-422f7d1d52889060.png"><link rel="icon" type="image/svg+xml" href="../static.files/favicon-2c020d218678b618.svg"></head><body class="rustdoc mod crate"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="mobile-topbar"><button class="sidebar-menu-toggle" title="show sidebar"></button></nav><nav class="sidebar"><div class="sidebar-crate"><h2><a href="../pyo3_async_runtimes/index.html">pyo3_async_runtimes</a><span class="version">0.22.0</span></h2></div><div class="sidebar-elems"><ul class="block"><li><a id="all-types" href="all.html">All Items</a></li></ul><section><ul class="block"><li><a href="#reexports">Re-exports</a></li><li><a href="#modules">Modules</a></li><li><a href="#structs">Structs</a></li><li><a href="#functions">Functions</a></li></ul></section></div></nav><div class="sidebar-resizer"></div><main><div class="width-limiter"><rustdoc-search></rustdoc-search><section id="main-content" class="content"><div class="main-heading"><h1>Crate <a class="mod" href="#">pyo3_async_runtimes</a><button id="copy-path" title="Copy item path to clipboard">Copy item path</button></h1><span class="out-of-band"><a class="src" href="../src/pyo3_async_runtimes/lib.rs.html#1-678">source</a> · <button id="toggle-all-docs" title="collapse all docs">[<span>&#x2212;</span>]</button></span></div><details class="toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><p>Rust Bindings to the Python Asyncio Event Loop</p>
<h2 id="motivation"><a class="doc-anchor" href="#motivation">§</a>Motivation</h2>
<p>This crate aims to provide a convenient interface to manage the interop between Python and
Rust’s async/await models. It supports conversions between Rust and Python futures and manages
the event loops for both languages. Python’s threading model and GIL can make this interop a bit
trickier than one might expect, so there are a few caveats that users should be aware of.</p>
<h3 id="why-two-event-loops"><a class="doc-anchor" href="#why-two-event-loops">§</a>Why Two Event Loops</h3>
<p>Currently, we don’t have a way to run Rust futures directly on Python’s event loop. Likewise,
Python’s coroutines cannot be directly spawned on a Rust event loop. The two coroutine models
require some additional assistance from their event loops, so in all likelihood they will need
a new <em>unique</em> event loop that addresses the needs of both languages if the coroutines are to
be run on the same loop.</p>
<p>It’s not immediately clear that this would provide worthwhile performance wins either, so in the
interest of getting something simple out there to facilitate these conversions, this crate
handles the communication between <em>separate</em> Python and Rust event loops.</p>
<h3 id="pythons-event-loop-and-the-main-thread"><a class="doc-anchor" href="#pythons-event-loop-and-the-main-thread">§</a>Python’s Event Loop and the Main Thread</h3>
<p>Python is very picky about the threads used by the <code>asyncio</code> executor. In particular, it needs
to have control over the main thread in order to handle signals like CTRL-C correctly. This
means that Cargo’s default test harness will no longer work since it doesn’t provide a method of
overriding the main function to add our event loop initialization and finalization.</p>
<h3 id="event-loop-references-and-contextvars"><a class="doc-anchor" href="#event-loop-references-and-contextvars">§</a>Event Loop References and ContextVars</h3>
<p>One problem that arises when interacting with Python’s asyncio library is that the functions we
use to get a reference to the Python event loop can only be called in certain contexts. Since
PyO3 Asyncio needs to interact with Python’s event loop during conversions, the context of these
conversions can matter a lot.</p>
<p>Likewise, Python’s <code>contextvars</code> library can require some special treatment. Python functions
and coroutines can rely on the context of outer coroutines to function correctly, so this
library needs to be able to preserve <code>contextvars</code> during conversions.</p>
<blockquote>
<p>The core conversions we’ve mentioned so far in the README should insulate you from these
concerns in most cases. For the edge cases where they don’t, this section should provide you
with the information you need to solve these problems.</p>
</blockquote>
<h4 id="the-main-dilemma"><a class="doc-anchor" href="#the-main-dilemma">§</a>The Main Dilemma</h4>
<p>Python programs can have many independent event loop instances throughout the lifetime of the
application (<code>asyncio.run</code> for example creates its own event loop each time it’s called for
instance), and they can even run concurrent with other event loops. For this reason, the most
correct method of obtaining a reference to the Python event loop is via
<code>asyncio.get_running_loop</code>.</p>
<p><code>asyncio.get_running_loop</code> returns the event loop associated with the current OS thread. It can
be used inside Python coroutines to spawn concurrent tasks, interact with timers, or in our case
signal between Rust and Python. This is all well and good when we are operating on a Python
thread, but since Rust threads are not associated with a Python event loop,
<code>asyncio.get_running_loop</code> will fail when called on a Rust runtime.</p>
<p><code>contextvars</code> operates in a similar way, though the current context is not always associated
with the current OS thread. Different contexts can be associated with different coroutines even
if they run on the same OS thread.</p>
<h4 id="the-solution"><a class="doc-anchor" href="#the-solution">§</a>The Solution</h4>
<p>A really straightforward way of dealing with this problem is to pass references to the
associated Python event loop and context for every conversion. That’s why we have a structure
called <code>TaskLocals</code> and a set of conversions that accept it.</p>
<p><code>TaskLocals</code> stores the current event loop, and allows the user to copy the current Python
context if necessary. The following conversions will use these references to perform the
necessary conversions and restore Python context when needed:</p>
<ul>
<li><code>pyo3_async_runtimes::into_future_with_locals</code> - Convert a Python awaitable into a Rust future.</li>
<li><code>pyo3_async_runtimes::&lt;runtime&gt;::future_into_py_with_locals</code> - Convert a Rust future into a Python
awaitable.</li>
<li><code>pyo3_async_runtimes::&lt;runtime&gt;::local_future_into_py_with_locals</code> - Convert a <code>!Send</code> Rust future
into a Python awaitable.</li>
</ul>
<p>One clear disadvantage to this approach is that the Rust application has to explicitly track
these references. In native libraries, we can’t make any assumptions about the underlying event
loop, so the only reliable way to make sure our conversions work properly is to store these
references at the callsite to use later on.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>pyo3::{wrap_pyfunction, prelude::<span class="kw-2">*</span>};

<span class="attr">#[pyfunction]
</span><span class="kw">fn </span>sleep(py: Python) -&gt; PyResult&lt;Bound&lt;PyAny&gt;&gt; {
    <span class="comment">// Construct the task locals structure with the current running loop and context
    </span><span class="kw">let </span>locals = pyo3_async_runtimes::TaskLocals::with_running_loop(py)<span class="question-mark">?</span>.copy_context(py)<span class="question-mark">?</span>;

    <span class="comment">// Convert the async move { } block to a Python awaitable
    </span>pyo3_async_runtimes::tokio::future_into_py_with_locals(py, locals.clone_ref(py), <span class="kw">async move </span>{
        <span class="kw">let </span>py_sleep = Python::with_gil(|py| {
            <span class="comment">// Sometimes we need to call other async Python functions within
            // this future. In order for this to work, we need to track the
            // event loop from earlier.
            </span>pyo3_async_runtimes::into_future_with_locals(
                <span class="kw-2">&amp;</span>locals,
                py.import_bound(<span class="string">"asyncio"</span>)<span class="question-mark">?</span>.call_method1(<span class="string">"sleep"</span>, (<span class="number">1</span>,))<span class="question-mark">?
            </span>)
        })<span class="question-mark">?</span>;

        py_sleep.<span class="kw">await</span><span class="question-mark">?</span>;

        <span class="prelude-val">Ok</span>(())
    })
}

<span class="attr">#[pymodule]
</span><span class="kw">fn </span>my_mod(py: Python, m: <span class="kw-2">&amp;</span>Bound&lt;<span class="lifetime">'_</span>, PyModule&gt;) -&gt; PyResult&lt;()&gt; {
    m.add_function(<span class="macro">wrap_pyfunction!</span>(sleep, m)<span class="question-mark">?</span>)<span class="question-mark">?</span>;
    <span class="prelude-val">Ok</span>(())
}</code></pre></div>
<blockquote>
<p>A naive solution to this tracking problem would be to cache a global reference to the asyncio
event loop that all PyO3 Asyncio conversions can use. In fact this is what we did in PyO3
Asyncio <code>v0.13</code>. This works well for applications, but it soon became clear that this is not
so ideal for libraries. Libraries usually have no direct control over how the event loop is
managed, they’re just expected to work with any event loop at any point in the application.
This problem is compounded further when multiple event loops are used in the application since
the global reference will only point to one.</p>
</blockquote>
<p>Another disadvantage to this explicit approach that is less obvious is that we can no longer
call our <code>#[pyfunction] fn sleep</code> on a Rust runtime since <code>asyncio.get_running_loop</code> only works
on Python threads! It’s clear that we need a slightly more flexible approach.</p>
<p>In order to detect the Python event loop at the callsite, we need something like
<code>asyncio.get_running_loop</code> and <code>contextvars.copy_context</code> that works for <em>both Python and Rust</em>.
In Python, <code>asyncio.get_running_loop</code> uses thread-local data to retrieve the event loop
associated with the current thread. What we need in Rust is something that can retrieve the
Python event loop and contextvars associated with the current Rust <em>task</em>.</p>
<p>Enter <code>pyo3_async_runtimes::&lt;runtime&gt;::get_current_locals</code>. This function first checks task-local data
for the <code>TaskLocals</code>, then falls back on <code>asyncio.get_running_loop</code> and
<code>contextvars.copy_context</code> if no task locals are found. This way both bases are
covered.</p>
<p>Now, all we need is a way to store the <code>TaskLocals</code> for the Rust future. Since this is a
runtime-specific feature, you can find the following functions in each runtime module:</p>
<ul>
<li><code>pyo3_async_runtimes::&lt;runtime&gt;::scope</code> - Store the task-local data when executing the given Future.</li>
<li><code>pyo3_async_runtimes::&lt;runtime&gt;::scope_local</code> - Store the task-local data when executing the given
<code>!Send</code> Future.</li>
</ul>
<p>With these new functions, we can make our previous example more correct:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>pyo3::prelude::<span class="kw-2">*</span>;

<span class="attr">#[pyfunction]
</span><span class="kw">fn </span>sleep(py: Python) -&gt; PyResult&lt;Bound&lt;PyAny&gt;&gt; {
    <span class="comment">// get the current event loop through task-local data
    // OR `asyncio.get_running_loop` and `contextvars.copy_context`
    </span><span class="kw">let </span>locals = pyo3_async_runtimes::tokio::get_current_locals(py)<span class="question-mark">?</span>;

    pyo3_async_runtimes::tokio::future_into_py_with_locals(
        py,
        locals.clone_ref(py),
        <span class="comment">// Store the current locals in task-local data
        </span>pyo3_async_runtimes::tokio::scope(locals.clone_ref(py), <span class="kw">async move </span>{
            <span class="kw">let </span>py_sleep = Python::with_gil(|py| {
                pyo3_async_runtimes::into_future_with_locals(
                    <span class="comment">// Now we can get the current locals through task-local data
                    </span><span class="kw-2">&amp;</span>pyo3_async_runtimes::tokio::get_current_locals(py)<span class="question-mark">?</span>,
                    py.import_bound(<span class="string">"asyncio"</span>)<span class="question-mark">?</span>.call_method1(<span class="string">"sleep"</span>, (<span class="number">1</span>,))<span class="question-mark">?
                </span>)
            })<span class="question-mark">?</span>;

            py_sleep.<span class="kw">await</span><span class="question-mark">?</span>;

            <span class="prelude-val">Ok</span>(Python::with_gil(|py| py.<span class="prelude-val">None</span>()))
        })
    )
}

<span class="attr">#[pyfunction]
</span><span class="kw">fn </span>wrap_sleep(py: Python) -&gt; PyResult&lt;Bound&lt;PyAny&gt;&gt; {
    <span class="comment">// get the current event loop through task-local data
    // OR `asyncio.get_running_loop` and `contextvars.copy_context`
    </span><span class="kw">let </span>locals = pyo3_async_runtimes::tokio::get_current_locals(py)<span class="question-mark">?</span>;

    pyo3_async_runtimes::tokio::future_into_py_with_locals(
        py,
        locals.clone_ref(py),
        <span class="comment">// Store the current locals in task-local data
        </span>pyo3_async_runtimes::tokio::scope(locals.clone_ref(py), <span class="kw">async move </span>{
            <span class="kw">let </span>py_sleep = Python::with_gil(|py| {
                pyo3_async_runtimes::into_future_with_locals(
                    <span class="kw-2">&amp;</span>pyo3_async_runtimes::tokio::get_current_locals(py)<span class="question-mark">?</span>,
                    <span class="comment">// We can also call sleep within a Rust task since the
                    // locals are stored in task local data
                    </span>sleep(py)<span class="question-mark">?
                </span>)
            })<span class="question-mark">?</span>;

            py_sleep.<span class="kw">await</span><span class="question-mark">?</span>;

            <span class="prelude-val">Ok</span>(Python::with_gil(|py| py.<span class="prelude-val">None</span>()))
        })
    )
}

<span class="attr">#[pymodule]
</span><span class="kw">fn </span>my_mod(py: Python, m: <span class="kw-2">&amp;</span>Bound&lt;<span class="lifetime">'_</span>, PyModule&gt;) -&gt; PyResult&lt;()&gt; {
    m.add_function(<span class="macro">wrap_pyfunction!</span>(sleep, m)<span class="question-mark">?</span>)<span class="question-mark">?</span>;
    m.add_function(<span class="macro">wrap_pyfunction!</span>(wrap_sleep, m)<span class="question-mark">?</span>)<span class="question-mark">?</span>;
    <span class="prelude-val">Ok</span>(())
}</code></pre></div>
<p>Even though this is more correct, it’s clearly not more ergonomic. That’s why we introduced a
set of functions with this functionality baked in:</p>
<ul>
<li><code>pyo3_async_runtimes::&lt;runtime&gt;::into_future</code>
<blockquote>
<p>Convert a Python awaitable into a Rust future (using
<code>pyo3_async_runtimes::&lt;runtime&gt;::get_current_locals</code>)</p>
</blockquote>
</li>
<li><code>pyo3_async_runtimes::&lt;runtime&gt;::future_into_py</code>
<blockquote>
<p>Convert a Rust future into a Python awaitable (using
<code>pyo3_async_runtimes::&lt;runtime&gt;::get_current_locals</code> and <code>pyo3_async_runtimes::&lt;runtime&gt;::scope</code> to set the
task-local event loop for the given Rust future)</p>
</blockquote>
</li>
<li><code>pyo3_async_runtimes::&lt;runtime&gt;::local_future_into_py</code>
<blockquote>
<p>Convert a <code>!Send</code> Rust future into a Python awaitable (using
<code>pyo3_async_runtimes::&lt;runtime&gt;::get_current_locals</code> and <code>pyo3_async_runtimes::&lt;runtime&gt;::scope_local</code> to
set the task-local event loop for the given Rust future).</p>
</blockquote>
</li>
</ul>
<p><strong>These are the functions that we recommend using</strong>. With these functions, the previous example
can be rewritten to be more compact:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>pyo3::prelude::<span class="kw-2">*</span>;

<span class="attr">#[pyfunction]
</span><span class="kw">fn </span>sleep(py: Python) -&gt; PyResult&lt;Bound&lt;PyAny&gt;&gt; {
    pyo3_async_runtimes::tokio::future_into_py(py, <span class="kw">async move </span>{
        <span class="kw">let </span>py_sleep = Python::with_gil(|py| {
            pyo3_async_runtimes::tokio::into_future(
                py.import_bound(<span class="string">"asyncio"</span>)<span class="question-mark">?</span>.call_method1(<span class="string">"sleep"</span>, (<span class="number">1</span>,))<span class="question-mark">?
            </span>)
        })<span class="question-mark">?</span>;

        py_sleep.<span class="kw">await</span><span class="question-mark">?</span>;

        <span class="prelude-val">Ok</span>(Python::with_gil(|py| py.<span class="prelude-val">None</span>()))
    })
}

<span class="attr">#[pyfunction]
</span><span class="kw">fn </span>wrap_sleep(py: Python) -&gt; PyResult&lt;Bound&lt;PyAny&gt;&gt; {
    pyo3_async_runtimes::tokio::future_into_py(py, <span class="kw">async move </span>{
        <span class="kw">let </span>py_sleep = Python::with_gil(|py| {
            pyo3_async_runtimes::tokio::into_future(sleep(py)<span class="question-mark">?</span>)
        })<span class="question-mark">?</span>;

        py_sleep.<span class="kw">await</span><span class="question-mark">?</span>;

        <span class="prelude-val">Ok</span>(Python::with_gil(|py| py.<span class="prelude-val">None</span>()))
    })
}

<span class="attr">#[pymodule]
</span><span class="kw">fn </span>my_mod(py: Python, m: <span class="kw-2">&amp;</span>Bound&lt;<span class="lifetime">'_</span>, PyModule&gt;) -&gt; PyResult&lt;()&gt; {
    m.add_function(<span class="macro">wrap_pyfunction!</span>(sleep, m)<span class="question-mark">?</span>)<span class="question-mark">?</span>;
    m.add_function(<span class="macro">wrap_pyfunction!</span>(wrap_sleep, m)<span class="question-mark">?</span>)<span class="question-mark">?</span>;
    <span class="prelude-val">Ok</span>(())
}</code></pre></div>
<blockquote>
<p>A special thanks to <a href="https://github.com/ShadowJonathan">@ShadowJonathan</a> for helping with the
design and review of these changes!</p>
</blockquote>
<h3 id="rusts-event-loop"><a class="doc-anchor" href="#rusts-event-loop">§</a>Rust’s Event Loop</h3>
<p>Currently only the Async-Std and Tokio runtimes are supported by this crate. If you need support
for another runtime, feel free to make a request on GitHub (or attempt to add support yourself
with the <a href="generic/index.html" title="mod pyo3_async_runtimes::generic"><code>generic</code></a> module)!</p>
<blockquote>
<p><em>In the future, we may implement first class support for more Rust runtimes. Contributions are
welcome as well!</em></p>
</blockquote>
<h3 id="features"><a class="doc-anchor" href="#features">§</a>Features</h3>
<p>Items marked with
&lt;span
class=“module-item stab portability”
style=“display: inline; border-radius: 3px; padding: 2px; font-size: 80%; line-height: 1.2;”</p>
<blockquote>
<p><code>attributes</code></span>
are only available when the <code>attributes</code> Cargo feature is enabled:</p>
</blockquote>
<div class="example-wrap"><pre class="language-toml"><code>[dependencies.pyo3-async-runtimes]
version = &quot;0.22&quot;
features = [&quot;attributes&quot;]
</code></pre></div>
<p>Items marked with
&lt;span
class=“module-item stab portability”
style=“display: inline; border-radius: 3px; padding: 2px; font-size: 80%; line-height: 1.2;”</p>
<blockquote>
<p><code>async-std-runtime</code></span>
are only available when the <code>async-std-runtime</code> Cargo feature is enabled:</p>
</blockquote>
<div class="example-wrap"><pre class="language-toml"><code>[dependencies.pyo3-async-runtimes]
version = &quot;0.22&quot;
features = [&quot;async-std-runtime&quot;]
</code></pre></div>
<p>Items marked with
&lt;span
class=“module-item stab portability”
style=“display: inline; border-radius: 3px; padding: 2px; font-size: 80%; line-height: 1.2;”</p>
<blockquote>
<p><code>tokio-runtime</code></span>
are only available when the <code>tokio-runtime</code> Cargo feature is enabled:</p>
</blockquote>
<div class="example-wrap"><pre class="language-toml"><code>[dependencies.pyo3-async-runtimes]
version = &quot;0.22&quot;
features = [&quot;tokio-runtime&quot;]
</code></pre></div>
<p>Items marked with
&lt;span
class=“module-item stab portability”
style=“display: inline; border-radius: 3px; padding: 2px; font-size: 80%; line-height: 1.2;”</p>
<blockquote>
<p><code>testing</code></span>
are only available when the <code>testing</code> Cargo feature is enabled:</p>
</blockquote>
<div class="example-wrap"><pre class="language-toml"><code>[dependencies.pyo3-async-runtimes]
version = &quot;0.22&quot;
features = [&quot;testing&quot;]
</code></pre></div></div></details><h2 id="reexports" class="section-header">Re-exports<a href="#reexports" class="anchor">§</a></h2><ul class="item-table"><li><div class="item-name" id="reexport.inventory"><code>pub use <a class="mod" href="https://docs.rs/inventory/0.3.15/inventory/index.html" title="mod inventory">inventory</a>;</code></div></li></ul><h2 id="modules" class="section-header">Modules<a href="#modules" class="anchor">§</a></h2><ul class="item-table"><li><div class="item-name"><a class="mod" href="async_std/index.html" title="mod pyo3_async_runtimes::async_std">async_std</a></div><div class="desc docblock-short"><span class="module-item stab portability" style="display: inline; border-radius: 3px; padding: 2px; font-size: 80%; line-height: 1.2;"><code>async-std-runtime</code></span> PyO3 Asyncio functions specific to the async-std runtime</div></li><li><div class="item-name"><a class="mod" href="err/index.html" title="mod pyo3_async_runtimes::err">err</a></div><div class="desc docblock-short">Errors and exceptions related to PyO3 Asyncio</div></li><li><div class="item-name"><a class="mod" href="generic/index.html" title="mod pyo3_async_runtimes::generic">generic</a></div><div class="desc docblock-short">Generic implementations of PyO3 Asyncio utilities that can be used for any Rust runtime</div></li><li><div class="item-name"><a class="mod" href="testing/index.html" title="mod pyo3_async_runtimes::testing">testing</a></div><div class="desc docblock-short"><span class="module-item stab portability" style="display: inline; border-radius: 3px; padding: 2px; font-size: 80%; line-height: 1.2;"><code>testing</code></span> Utilities for writing PyO3 Asyncio tests</div></li><li><div class="item-name"><a class="mod" href="tokio/index.html" title="mod pyo3_async_runtimes::tokio">tokio</a></div><div class="desc docblock-short"><span class="module-item stab portability" style="display: inline; border-radius: 3px; padding: 2px; font-size: 80%; line-height: 1.2;"><code>tokio-runtime</code></span> PyO3 Asyncio functions specific to the tokio runtime</div></li></ul><h2 id="structs" class="section-header">Structs<a href="#structs" class="anchor">§</a></h2><ul class="item-table"><li><div class="item-name"><a class="struct" href="struct.TaskLocals.html" title="struct pyo3_async_runtimes::TaskLocals">TaskLocals</a></div><div class="desc docblock-short">Task-local data to store for Python conversions.</div></li></ul><h2 id="functions" class="section-header">Functions<a href="#functions" class="anchor">§</a></h2><ul class="item-table"><li><div class="item-name"><a class="fn" href="fn.get_running_loop.html" title="fn pyo3_async_runtimes::get_running_loop">get_running_loop</a></div><div class="desc docblock-short">Get a reference to the Python Event Loop from Rust</div></li><li><div class="item-name"><a class="fn" href="fn.into_future_with_locals.html" title="fn pyo3_async_runtimes::into_future_with_locals">into_future_with_locals</a></div><div class="desc docblock-short">Convert a Python <code>awaitable</code> into a Rust Future</div></li></ul></section></div></main></body></html>